class_name VoxelChunk extends Node

const SIZE_X=24
const SIZE_Y=24
const SIZE_Z=24

var entity_manager:EntityManager

# CORE DATA
var chunk_coord : Vector3i 
var voxels: Array[Vector3i] = [] # could replace with packedin array, but fine as is for now)
var voxel_properties: Array[Array] = [] # entires of form: [blocktype,tx,ty,rot,vflip,layer]

# GENERATED DATA

# scene object
var meshInstance:MeshInstance3D
var static_body:StaticBody3D
var collision_shape:CollisionShape3D

# voxel->properties dictionary  ( entires of form: [blocktype,tx,ty,rot,vflip,layer] )
# (kept up to date as I add/remove voxels)
var voxel_dict: Dictionary = {}
# generated by regen_mesh
var tri_voxel_info: PackedInt32Array = PackedInt32Array()

# CONSTANTS
const TEX_TILEMAP:Texture2D = preload("res://VoxelWorld/Textures/tilemap.png")
var TEX_WIDTH:float = TEX_TILEMAP.get_width()
var TEX_HEIGHT:float = TEX_TILEMAP.get_height()
const TILE_W:float=16
const TILE_H:float=16
var TILE_W_LOCAL : float = TILE_W/TEX_WIDTH
var TILE_H_LOCAL : float = TILE_H/TEX_HEIGHT
var du : Vector2 = Vector2(TILE_W_LOCAL,0)
var dv : Vector2 = Vector2(0,TILE_H_LOCAL)

const FACE_UV_COLGROUP_SIZE:int=3

# OTHER STUFF 
var noise1:FastNoiseLite = FastNoiseLite.new()
var noise2:FastNoiseLite = FastNoiseLite.new()
var noise3:FastNoiseLite = FastNoiseLite.new()

const tilemap_mat_path:Material = preload("res://VoxelWorld/Materials/tilemap.tres")
const tilemap_mat_editor_path:Material = preload("res://VoxelWorld/Materials/tilemap_editor.tres")
func set_game_mode(editor_mode:bool)->void:
	if editor_mode:
		meshInstance.material_override = tilemap_mat_editor_path
	else:
		meshInstance.material_override = tilemap_mat_path
		
		
func _init(_chunk_coord:Vector3i,_entity_manager:EntityManager) -> void:	
	chunk_coord=_chunk_coord
	meshInstance = MeshInstance3D.new()
	if ModeManager.mode==ModeManager.MODE_GAME:
		meshInstance.material_override = tilemap_mat_path 
	else:
		meshInstance.material_override = tilemap_mat_editor_path 
	
	meshInstance.set_layer_mask_value(5,true)
	self.add_child(meshInstance)
	
	self.entity_manager=_entity_manager
	
	# Create a StaticBody3D to serve as the container for the mesh and collider.
	static_body = StaticBody3D.new()
	static_body.set_collision_layer_value(10,true)
	static_body.set_meta("chunk_coord", chunk_coord)
	meshInstance.add_child(static_body)

	# Create the CollisionShape3D as a child of the StaticBody3D.
	collision_shape = CollisionShape3D.new()
	static_body.add_child(collision_shape)
	
	noise1.seed=13123123
	noise2.seed=123123
	noise3.seed=132
	
	noise1.frequency = 12424.12
	noise2.frequency = 23123.23
	noise3.frequency = 4123.4124
	
	noise1.noise_type = FastNoiseLite.TYPE_VALUE
	noise2.noise_type = FastNoiseLite.TYPE_VALUE
	noise3.noise_type = FastNoiseLite.TYPE_VALUE
	
func add_voxel(v:Vector3i,props:Array,undo_buffer:Array[Array]):
	if voxel_dict.has(v)||entity_manager.occupied_by_entity(v):
		return
	voxels.push_back(v)	
	voxel_properties.push_back(props)
	voxel_dict[v]=props
	undo_buffer.push_back([v])	
	regen_mesh()
	
func add_voxel_unsafe(v:Vector3i,props:Array,undo_buffer:Array[Array]):
	if voxel_dict.has(v)||entity_manager.occupied_by_entity(v):
		return
	voxels.push_back(v)	
	voxel_properties.push_back(props)
	voxel_dict[v]=props
	undo_buffer.push_back([v])

func add_voxel_unsafer(v:Vector3i,props:Array):
	voxels.push_back(v)	
	voxel_properties.push_back(props)
	voxel_dict[v]=props
		
func add_face_at(new_voxel:Vector3i,tx:int,ty:int,blocktype:int,rot:int,vflip:bool,layer_idx:int,undo_buffer:Array[Array]):
	#check it isn't in there already	
	if voxel_dict.has(new_voxel)||entity_manager.occupied_by_entity(new_voxel):
		return
	var prop = [blocktype,tx,ty,rot,vflip,layer_idx]
	voxels.push_back(new_voxel)
	voxel_properties.push_back(prop)
	voxel_dict[new_voxel]=prop
	undo_buffer.push_back([new_voxel])
	regen_mesh()

func clamp_lower(a:Vector3i)->Vector3i:	
	return Vector3i(
		a.x if a.x>chunk_coord.x*SIZE_X else chunk_coord.x*SIZE_X,
		a.y if a.y>chunk_coord.y*SIZE_Y else chunk_coord.y*SIZE_Y,
		a.z if a.z>chunk_coord.z*SIZE_Z else chunk_coord.z*SIZE_Z
	)
	
func clamp_upper(a:Vector3i)->Vector3i:
	return Vector3i(
		a.x if a.x<(chunk_coord.x+1)*SIZE_X else (chunk_coord.x+1)*SIZE_X-1,
		a.y if a.y<(chunk_coord.y+1)*SIZE_Y else (chunk_coord.y+1)*SIZE_Y-1,
		a.z if a.z<(chunk_coord.z+1)*SIZE_Z else (chunk_coord.z+1)*SIZE_Z-1
	)

func valid_coord(a:Vector3i)->bool:
	return 	a.x>=chunk_coord.x*SIZE_X && \
			a.y>=chunk_coord.y*SIZE_Y && \
			a.z>=chunk_coord.z*SIZE_Z && \
			a.x<(chunk_coord.x+1)*SIZE_X && \
			a.y<(chunk_coord.y+1)*SIZE_Y && \
			a.z<(chunk_coord.z+1)*SIZE_Z
			
func remove_range(vmin:Vector3i,vmax:Vector3i,undo_buffer:Array[Array],ramp:Vector3i,ramp_origin:Vector3i):
	# removing all cubes inside the bounding box of a and b	
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	for i in range(voxels.size()-1,-1,-1):
		var v:Vector3i = voxels[i]
		v += Glob.vtrace((v-ramp_origin)*ramp)*Vector3i.UP
		if vmin.x<=v.x && v.x<=vmax.x && vmin.y<=v.y && v.y<=vmax.y && vmin.z<=v.z && v.z<=vmax.z:
			undo_buffer.push_back([v,voxel_properties[i]])
			voxels.remove_at(i)
			voxel_properties.remove_at(i)
			voxel_dict.erase(v)	
	regen_mesh()
	
func add_range(vmin:Vector3i,vmax:Vector3i,tx:int,ty:int,blocktype:int,rot:int,vflip:bool,layer:int,undo_buffer:Array[Array],ramp:Vector3i,ramp_origin:Vector3i):
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	for x:int in range(vmin.x,vmax.x+1):
		for y:int in range(vmin.y,vmax.y+1):
			for z:int in range(vmin.z,vmax.z+1):
				var voxel=Vector3i(x,y,z)
				voxel += Glob.vtrace((voxel-ramp_origin)*ramp)*Vector3i.UP
				if !voxel_dict.has(voxel) && !entity_manager.occupied_by_entity(voxel):
					var props = [blocktype,tx,ty,rot,vflip,layer]
					voxels.push_back(voxel)
					voxel_properties.push_back(props)
					voxel_dict[voxel]=props
					undo_buffer.push_back([voxel])
	regen_mesh()

func fill_volume(vmin:Vector3i,vmax:Vector3i,tx:int,ty:int,blocktype:int,rot:int,vflip:bool,layer:int,undo_buffer:Array[Array]):
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	for x:int in range(vmin.x,vmax.x+1):
		for y:int in range(vmin.y,vmax.y+1):
			for z:int in range(vmin.z,vmax.z+1):
				var voxel=Vector3i(x,y,z)
				if !voxel_dict.has(voxel) && !entity_manager.occupied_by_entity(voxel):
					var props = [blocktype,tx,ty,rot,vflip,layer]
					voxels.push_back(voxel)
					voxel_properties.push_back(props)
					voxel_dict[voxel]=props
					undo_buffer.push_back([voxel])
	regen_mesh()

func delete_volume(vmin:Vector3i,vmax:Vector3i,undo_buffer:Array[Array]):
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	for i in range(voxels.size()-1,-1,-1):
		var v:Vector3i = voxels[i]
		if vmin.x<=v.x && v.x<=vmax.x && vmin.y<=v.y && v.y<=vmax.y && vmin.z<=v.z && v.z<=vmax.z:
			undo_buffer.push_back([v,voxel_properties[i]])
			voxels.remove_at(i)
			voxel_properties.remove_at(i)
			voxel_dict.erase(v)	
	regen_mesh()

func add_ball(centre:Vector3i,selected_tileset_item:int,selected_tileset_row:int,ball_radius:int,layer_idx:int,undo_buffer:Array[Array]):
	var vmin:Vector3i = Vector3i(centre.x-ball_radius,centre.y-ball_radius,centre.z-ball_radius)
	var vmax:Vector3i = Vector3i(centre.x+ball_radius,centre.y+ball_radius,centre.z+ball_radius)	
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	
	if ball_radius==1: #different path for tiny sphere so it looks nice
		for x in range(vmin.x,vmax.x+1):
			for y in range(vmin.y,vmax.y+1):
				for z in range(vmin.z,vmax.z+1):
					var v = Vector3i(x,y,z)
					var radius = (v-centre).length()
					if radius*radius>=1.5:
						continue
							
					if voxel_dict.has(v) || entity_manager.occupied_by_entity(v):
						continue					

					voxels.push_back(v)		
					var prop = 	[0,selected_tileset_item,selected_tileset_row,randi_range(0,3),false,layer_idx]
					voxel_properties.push_back(prop)
					voxel_dict[v]=prop
					undo_buffer.push_back([v])
	else:
		for x in range(vmin.x,vmax.x+1):
			for y in range(vmin.y,vmax.y+1):
				for z in range(vmin.z,vmax.z+1):
					var v = Vector3i(x,y,z)
					var radius = (v-centre).length()
					if round(radius)>=ball_radius:
						continue
							
					if voxel_dict.has(v)|| entity_manager.occupied_by_entity(v):
						continue					

					voxels.push_back(v)		
					var prop = 	[0,selected_tileset_item,selected_tileset_row,randi_range(0,3),false,layer_idx]
					voxel_properties.push_back(prop)
					voxel_dict[v]=prop
					undo_buffer.push_back([v])
					
	regen_mesh()


func remove_ball(centre:Vector3i,ball_radius:int,undo_buffer:Array[Array],removecubes:bool=true,tx:int=-1,ty:int=-1):
	
	var vmin:Vector3i = Vector3i(centre.x-ball_radius,centre.y-ball_radius,centre.z-ball_radius)
	var vmax:Vector3i = Vector3i(centre.x+ball_radius,centre.y+ball_radius,centre.z+ball_radius)	
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	
	var voxels_to_remove:Array[Vector3i]=[]
	
	for x in range(vmin.x,vmax.x+1):
		for y in range(vmin.y,vmax.y+1):
			for z in range(vmin.z,vmax.z+1):
				var v = Vector3i(x,y,z)
				var radius = (v-centre).length()
				if radius>ball_radius:
					continue
				voxels_to_remove.push_back(v)
				
	for i in range(voxels.size()-1,-1,-1):
		var v:Vector3i = voxels[i]
		var idx = voxels_to_remove.find(v)
		if idx>=0:
			if removecubes==false:
				var props = self.voxel_properties[i]
				if props[0]==Shapes.CUBE || props[0]==Shapes.PYRAMID || props[0]==Shapes.STAIRS || props[0]==Shapes.PILLAR || props[0]==Shapes.WALL:
					continue
			if tx!=-1:
				var props = self.voxel_properties[i]
				if props[1]!=tx || props[2]!=ty:
					continue
			undo_buffer.push_back([v,voxel_properties[i]])
			voxels.remove_at(i)
			voxel_properties.remove_at(i)	
			voxel_dict.erase(v)		
	regen_mesh()

	
func is_occupied(voxel:Vector3i)->bool:
	return voxel_dict.has(voxel)
	
func is_occupied_by_visible_voxel(voxel:Vector3i,layers:Array)->bool:
	if !voxel_dict.has(voxel):
		return false
	var props = voxel_dict[voxel]
	var layer:int = props[5]
	if !layers[layer].visible:
		return false
	return true
	
func get_voxel(tri_index:int)->Vector3i:
	#face index will be the cube_index*faceount + face_index
	if tri_index==-1 || tri_index * 2 >= tri_voxel_info.size():
		printerr("oh ho trying to access element #",tri_index," of array of size ",tri_voxel_info.size())
		return Vector3i(0,0,0)
	var cube_index : int = tri_voxel_info[tri_index * 2]
	
	if cube_index>=voxels.size():
		printerr("oh ho trying to access cube_index #",cube_index," of array of size ",voxels.size())
		return Vector3i(0,0,0)
		
	var voxel_coord : Vector3i = voxels[cube_index]
	return voxel_coord
	
func get_side(tri_index:int)->int:
	if tri_index * 2 >= tri_voxel_info.size():
		printerr("oh ho trying to access element #",tri_index," of array of size ",tri_voxel_info.size())
		return 0
	var side_index : int = tri_voxel_info[tri_index * 2 + 1]
	return side_index
	
func get_voxel_properties(tri_index:int)->Array:
	#face index will be the cube_index*faceount + face_index
	if tri_index * 2 >= tri_voxel_info.size():
		printerr("oh ho trying to access element #",tri_index," of array of size ",tri_voxel_info.size())
		return []
	var cube_index : int = tri_voxel_info[tri_index * 2]
	var voxel_props : Array = voxel_properties[cube_index]
	return voxel_props
	
func get_piece_count_in_column(x:int,z:int)->int:
	var count:int=0
	for v in voxels:
		if v.x==x && v.z==z:
			count = count+1
	return count
	

func get_column_voxels(x:int,z:int)->Array[Vector3i]:
	var col:Array[Vector3i]=[]
	for v in voxels:
		if v.x==x && v.z==z:
			col.push_back(v)
	return col

func get_height_at(x:int,z:int)->int:
	var curmax=-6666
	for v in voxels:
		if v.x==x && v.z==z && v.y>curmax:
			curmax=v.y
	return curmax
	
func remove_at(voxel:Vector3i,undo_buffer:Array[Array]) -> bool:
	for i in range(voxels.size()):
		var v = voxels[i]
		if voxel==v:
			undo_buffer.push_back([v,voxel_properties[i]])
			voxels.remove_at(i)
			voxel_properties.remove_at(i)
			voxel_dict.erase(v)
			regen_mesh()
			return true
	return false
		
func remove_voxel_unsafe(voxel:Vector3i,undo_buffer:Array[Array]) -> bool:
	for i in range(voxels.size()):
		var v = voxels[i]
		if voxel==v:
			undo_buffer.push_back([v,voxel_properties[i]])
			voxels.remove_at(i)
			voxel_properties.remove_at(i)
			voxel_dict.erase(v)
			return true
	return false
	
func remove_face(tri_index:int,undo_buffer:Array[Array]):
	var cube_index : int = tri_voxel_info[tri_index][0]
	var voxel_coord : Vector3i = voxels[cube_index]
	#check it isn't in there already	
	for i in range(voxels.size()):
		var v = voxels[i]
		if v==voxel_coord:
			undo_buffer.push_back([v,voxel_properties[i]])
			voxels.remove_at(i)
			voxel_properties.remove_at(i)
			voxel_dict.erase(v)
			break
	regen_mesh()

func replace_tiles(from_tileset_item:int,from_tileset_row:int, to_tileset_item:int, to_tileset_row:int,in_layer_idx:int,undo_buffer:Array[Array]):
	var modified:bool=false
	for i in range(voxel_properties.size()):
		var props:Array = voxel_properties[i]
		if props[1]==from_tileset_item && props[2] == from_tileset_row && props[5]==in_layer_idx:
			var voxel:Vector3i=voxels[i]
			undo_buffer.push_back([voxel,props.duplicate()])			
			props[1]= to_tileset_item
			props[2] = to_tileset_row
			modified=true
	if modified:
		regen_mesh()

func set_voxel_properties(voxel:Vector3i,tx:int,ty:int,rot:int,vflip:bool,layer:int,undo_buffer:Array[Array])->bool:
		var voxel_properties_entry:Array = voxel_dict[voxel]		
		var voxel_shape = voxel_properties_entry[0]
		
		if voxel_properties_entry[1]!=tx \
			|| voxel_properties_entry[2]!=ty \
			|| ( voxel_shape==0 && (voxel_properties_entry[3]!=rot || voxel_properties_entry[4]!=vflip)) \
			|| voxel_properties_entry[5] != layer:
			
			undo_buffer.push_back([voxel,voxel_properties_entry.duplicate()])
			
			voxel_properties_entry[1]=tx
			voxel_properties_entry[2]=ty
			voxel_properties_entry[5]=layer
			#paint rot/flip ONLY if it's a normal cube
			if voxel_shape==0:
				voxel_properties_entry[3]=rot
				voxel_properties_entry[4]=vflip			
			
			return true
		
		return false
				
func paint_ball(centre:Vector3i,ball_radius:int,tx:int,ty:int,rot:int,vflip:bool,layer:int,undo_buffer:Array[Array]):
	var changed:bool=false
	
	var vmin:Vector3i = Vector3i(centre.x-ball_radius,centre.y-ball_radius,centre.z-ball_radius)
	var vmax:Vector3i = Vector3i(centre.x+ball_radius,centre.y+ball_radius,centre.z+ball_radius)	
	vmin = clamp_lower(vmin)
	vmax = clamp_upper(vmax)
	
	match ball_radius:
		0:			
			if voxel_dict.has(centre):			
				changed = set_voxel_properties(centre,tx,ty,rot,vflip,layer,undo_buffer)
			else: 
				pass
		1:	
			for x in range(vmin.x,vmax.x+1):
				for y in range(vmin.y,vmax.y+1):
					for z in range(vmin.z,vmax.z+1):
						var v = Vector3i(x,y,z)
						var radius = (v-centre).length()
						if radius*radius>=1.5:
							continue
								
						if !voxel_dict.has(v):
							continue		
							
						var this_changed = set_voxel_properties(v,tx,ty,rot,vflip,layer,undo_buffer)
						changed = changed || this_changed
		_:
			for x in range(vmin.x,vmax.x+1):
				for y in range(vmin.y,vmax.y+1):
					for z in range(vmin.z,vmax.z+1):
						var v = Vector3i(x,y,z)
						var radius = (v-centre).length()
						if round(radius)>=ball_radius:
							continue
								
						if !voxel_dict.has(v):
							continue					
							
						var this_changed = set_voxel_properties(v,tx,ty,rot,vflip,layer,undo_buffer)
						changed = changed || this_changed
					
	if changed:
		regen_mesh(false)					
	
func paint_face(tri_index:int,tx:int,ty:int,rot:int,vflip:bool,layer:int,undo_buffer:Array[Array]):
	#face index will be the cube_index*faceount + face_index
	var cube_index : int = tri_voxel_info[tri_index * 2]
	#var side_index : int = tri_voxel_info[tri_index * 2 + 1]
	var target_voxel : Vector3i = voxels[cube_index]
	#check it isn't in there already	
	for i in range(voxels.size()):
		var voxel:Vector3i = voxels[i]
		if voxel==target_voxel:
			var voxel_properties_entry:Array = voxel_properties[i]		
			undo_buffer.push_back([voxel,voxel_properties_entry.duplicate()])
			var voxel_shape = voxel_properties_entry[0]
			
			if voxel_properties_entry[1]!=tx \
					|| voxel_properties_entry[2]!=ty \
					||( voxel_shape==0 && (voxel_properties_entry[3]!=rot || voxel_properties_entry[4]!=vflip)) \
					|| voxel_properties_entry[5]!=layer:
						
				voxel_properties_entry[1]=tx
				voxel_properties_entry[2]=ty
				#paint rot/flip ONLY if it's a normal cube
				if voxel_shape==0:
					voxel_properties_entry[3]=rot
					voxel_properties_entry[4]=vflip
				regen_mesh()
	
func regen_mesh(regen_collision=true):
	
	var world = ModeManager.editor_node.voxel_world
	var layers = world.layers
	
	# Precalculate layer visibility
	var layer_visibility = []
	for l in layers:
		layer_visibility.push_back(l.visible)
	
	var mesh : ArrayMesh = ArrayMesh.new()
	
	if !world.mesher:
		print("VoxelChunk: Mesher not initialized yet")
		return

	var result:Dictionary = world.mesher.generate_chunk_mesh(chunk_coord,voxels,voxel_properties,layer_visibility,SIZE_X,SIZE_Y,SIZE_Z)
	
	var mesh_arrays = result["mesh_arrays"]
	tri_voxel_info = result["tri_voxel_info"]

	if mesh_arrays[Mesh.ARRAY_VERTEX].size() == 0:
		meshInstance.mesh = null
		if regen_collision:
			collision_shape.shape = null
		return

	mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, mesh_arrays)

	meshInstance.mesh = mesh
	if regen_collision:
		collision_shape.shape = mesh.create_trimesh_shape()
	
	
